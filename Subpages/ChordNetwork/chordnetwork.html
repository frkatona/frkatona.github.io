<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chord Network Diagram</title>
    <!-- <link rel="stylesheet" href="chordnetwork.css"> -->
</html>
<script src="https://d3js.org/d3.v4.min.js"></script>
<body>
    
    <style>
        .unselectable {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background-color: #161522;
        }

        #parameters label, #parameters select {
            display: inline-block;
            margin-bottom: 5px;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-weight: bold;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 10%;
            margin-top: 5px
        }

        #parameters input, #parameters select {
            display: inline-block;
            color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 10%;
        }

        .hamburger {
            font-size: 50px;
            cursor: pointer;
            top: 10px;
            left: 10px;
            /* position: fixed; */
        }

        .menu {
            display: none;
        }

        #bottomContainer {
            display: flex;
            /* justify-content: center;
            align-items: center; */
            position: fixed;
            bottom: 10px;
            width: 50%;
        }

        #chordBoxes {
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            bottom: 10px;
            width: 100%;
            height: 100px; /* Adjust as needed */
            background-color: #161522; /* Adjust as needed */
        }

        #chordBoxes > div {
            border: 5px solid #000;
            width: 100px; /* Adjust as needed */
            height: 100px; /* Adjust as needed */
            margin: 10px 10px; /* Adjust as needed */
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #fff;
            /* add outline to text */
            text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
            font-size: 25px;
            font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        #randomNext {
            position: fixed;
            bottom: 50px;
            left: 50px;
            z-index: 1;
            margin-left: 20px;
            background-color: white;
        }

        #exportMIDI {
            position: fixed;
            bottom: 20px;
            left: 50px;
            z-index: 1;
            margin-left: 20px;
        }
    </style>

    <script>
        // Global Constants
        //twelth root of two
        const twelthRoot = 1.0594630943592952645618252949463;
        const keyArray = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A","A#", "B"];
        const extensions = {
                0: "7",
                1: "",
                2: " add9",
                4: " add11"
            }
        let repeatTest = false;
        let repeatCounter = 0;
        
        // User parameters (audio)
        let key = 0;
        let volume = 0.2;
        let octaveSelect = 4;
        let attack = 0.1;
        let waveShape = "sine";
        let lowpassCutoff = 4000;
        let randomDelay = 1000;

        // User parameters (UI) [placeholder]
        let chordBars = 4; // use this to construct more boxes as a user UI control later

        // User parameters (chord quality)
        let openness = 3;
        let voiceLeading = 0.1;
        let butter = 0.5;
        let chordColor = 0;
        let lastNode = d3.select("#I");

        //random next toggle function
        function toggleRandomNext() {
            if (repeatTest == false) {
                repeatTest = true;
                document.getElementById("randomNext").style.backgroundColor = "green";
            } else {
                repeatTest = false;
                document.getElementById("randomNext").style.backgroundColor = "white";
            }
        }
    </script>
    
    <button class="hamburger" onclick="toggleMenu()">â˜°</button>

    <div id="parameters" class="menu">
        <form id="parameters">
            <label for="volume">Volume:</label>
            <input type="range" id="volume" name="volume" min="0" max="0.3" step="0.05">
            
            <label for="key">Key:</label>
            <select id="key" name="key">
                <option value="0">C</option>
                <option value="1">C#</option>
                <option value="2">D</option>
                <option value="3">D#</option>
                <option value="4">E</option>
                <option value="5">F</option>
                <option value="6">F#</option>
                <option value="7">G</option>
                <option value="8">G#</option>
                <option value="9">A</option>
                <option value="10">A#</option>
                <option value="11">B</option>
            </select>

            <label for="octaveSelect">Octave:</label>
            <select id="octaveSelect" name="octaveSelect" value="4">
                <option value="2">2</option>
                <option value="3" selected>3</option>
                <option value="4">4</option>
                <option value="5">5</option>
            </select>
            
            <label for="waveShape">Wave Shape:</label>
            <select id="waveShape" name="waveShape">
                <option value="sine">Sine</option>
                <option value="square">Square</option>
                <option value="sawtooth">Sawtooth</option>
                <option value="triangle">Triangle</option>
            </select>

            <label for="lowpassCutoff">Lowpass Cutoff:</label>
            <input type="range" id="lowpassCutoff" name="lowpassCutoff" min="300" max="12300" step="2000" oninput="this.title = this.value + ' Hz'">

            <label for="chordColor">Extension:</label>
            <select id="chordColor" name="chordColor">
                <option value="1">None</option>
                <option value="0" selected>7</option>
                <option value="2">add9</option>
                <option value="4">add11</option>
            </select>

            <label for="openness">Voice Openness:</label>
            <select id="openness" name="openness">
                <option value="1">Very Closed</option>
                <option value="2">Closed</option>
                <option value="3" selected>Original</option>
                <option value="4">Open</option>
                <option value="5">Very Open</option>
            </select>
        </form>
    </div>

    <div id="bottomContainer">
        <div id="chordBoxes">
            <div id="box1"></div>
            <div id="box2"></div>
            <div id="box3"></div>
            <div id="box4"></div>
        </div>
        <!-- onclick set randomNext to true and set background color to red -->
        <button id="randomNext" onclick="toggleRandomNext()">Random Next</button>
        <button id="exportMIDI">Export MIDI (todo)</button>
    </div>

    <script>
        const handlers = {
            'key': (value) => key = parseInt(value),
            'volume': (value) => volume = parseFloat(value),
            'octaveSelect': (value) => octaveSelect = parseInt(value),
            'waveShape': (value) => waveShape = value,
            'openness': (value) => openness = parseInt(value),
            'lowpassCutoff': (value) => lowpassCutoff = parseInt(value),
            'chordColor': (value) => chordColor = parseInt(value)
        };

        document.getElementById('parameters').addEventListener('change', function(e) {
            const handler = handlers[e.target.id];
            if (handler) {
                handler(e.target.value);
            }
        });

        function toggleMenu() {
            var menu = document.getElementById('parameters');
            if (menu.style.display !== 'block') {
                menu.style.display = 'block';
            } else {
                menu.style.display = 'none';
            }
        }
    </script>

    <script>
        var audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        var colors = ["#d00000", "#ffba08", "#3f88c5", "#032b43", "#136f63", "#66635b"];
        var svg = d3.select("body").append("svg")
        .attr("width", window.innerWidth)
        .attr("height", window.innerHeight);

        var color = d3.scaleOrdinal(d3.schemeCategory20);

        var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function(d) { return d.id; })
            .distance(500)  // Set the link distance
            .strength(0.05))  // Set the link strength
        .force("charge", d3.forceManyBody()
            .strength(-250)  // Make nodes repel each other more strongly
            .distanceMin(1)  // Avoid instability for very close nodes
            .distanceMax(100)  // Ignore nodes that are very far away
            .theta(.5))  // Make the simulation run faster but less accurately
        .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2.5));
            
        d3.json("chord-flow-D3.json", function(error, graph) {
            if (error) {
                console.error("Error loading file:", error);  // Log the error to the console
                return;
            }

        var linkColor = d3.scaleOrdinal()
            .domain(["natural", "driven", "delicate"])  // Add all possible types here
            .range([colors[0], colors[2], colors[4]]);  // Add the corresponding colors here

        svg.append("defs").selectAll("marker")
            .data(["end"])      // Different link/path types can be defined here
            .enter().append("marker")    // This section adds in the arrows
            .attr("id", String)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 20)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5");

        var link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graph.links)
            .enter().append("line")
            .attr("id", function(d) { return "link-" + d.id; })  // Assign an ID to each link
            .attr("stroke-width", function(d) { return Math.sqrt(d.value); })
            .attr("stroke", function(d) { return linkColor(d.type); })
            .attr("marker-end", "url(#end)");

        var node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(graph.nodes)
            .enter().append("circle")
            .attr("r", 50)
            .attr("fill", function(d) { return color(d.group); })
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        var labels = svg.append("g")
            .attr("class", "labels")
            .selectAll("text")
            .data(graph.nodes)
            .enter().append("text")
            .attr("class", "unselectable")
            .text(function(d) { return d.id; })
            .style("text-anchor", "middle")
            .style("fill", "#000")
            .style("font-family", "Arial")
            .style("font-size", 30)
            .call(d3.drag()  // Add the same drag handlers to the labels
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        function propagateEffect(node) {

            // Find the links connected to the node as a source
            let linksFrom = graph.links.filter(function(link) {
                return link.source === node;
            });
            // Create a transition for each link
            linksFrom.forEach(function(link) {
                d3.select("#link-" + link.id)
                    .transition()
                    .duration(attack * 2000)
                    .style("stroke", function(d) { return linkColor(d.type); })  // Change the color
                    .style("stroke-width", 8)  // Increase the stroke width
                    .transition()  // Add another transition
                    .duration(1000)  // Set the duration for the second transition
                    .style("stroke", function(d) { return linkColor(d.type); })  // Reset the color
                    .style("stroke-width", function(d) { return Math.sqrt(d.value); });  // Reset the stroke width
            });
            // pick a random node that is connected to the node as a target
            let linksTo = graph.links.filter(function(link) {
                return link.target === node;
            });
            let randomLink = linksTo[Math.floor(Math.random() * linksTo.length)];
            let randomNode = randomLink.source;
            
            if (repeatTest == true && repeatCounter < chordBars - 1) {
                setTimeout(function() { handleClick(randomNode); }, randomDelay);
                repeatCounter++;
            } else {
                repeatTest = false;
                repeatCounter = 0;
                document.getElementById("randomNext").style.backgroundColor = "white";

            }
        }

        var lastFourChords = [];

        function chordClicked(chordName, color) {
            // If there are already four chords, remove the first one
            if (lastFourChords.length === 4) {
                lastFourChords.shift();
            }

            // Add the new chord and its color
            lastFourChords.push({ identity: chordName, color: color });

            // Update the boxes
            for (var i = 0; i < lastFourChords.length; i++) {
                var box = document.getElementById('box' + (i + 1));
                box.textContent = lastFourChords[i].identity;
                box.style.backgroundColor = lastFourChords[i].color;
            }

            // add an animation to the box most recently changed (will be box4 except for first 3 clicks)

        }

        function handleClick(d) {
            // console.log(node.datum());

            // Define the frequencies for the notes starting from C1 and then correct for octave and key selection
            let frequencies = [32.70, 34.65, 36.71, 38.89, 41.20, 43.65, 46.25, 48.99, 51.91, 55.00, 58.27, 61.74, 65.41, 69.30, 73.42, 77.78, 82.41, 87.31, 92.50, 98.00, 103.83, 110.00, 116.54, 123.47]; // C1 to B2
            frequencies = frequencies.map(function(value) {
                octaveCorrected = value * Math.pow(2, octaveSelect - 1);
                keyCorrected = octaveCorrected * Math.pow(twelthRoot, key);
                return keyCorrected;
            });

            let chordShape = d.notes.map(note => frequencies[note]);
            
            let chordTonality;
            if (d.notes[1] - d.notes[0] == 3){
                chordTonality = "min";
            } else if (d.notes[3] - d.notes[0] == 11) {
                chordTonality = "maj";
            } else {
                chordTonality = "" //dominant
            }

            chordName = keyArray[(d.notes[0] + key + 12) % 12] + chordTonality + extensions[chordColor]
            console.log("d.notes[0]: " + d.notes[0]);
            console.log("key: " + key);
            console.log("keyArray.length: " + keyArray.length);
            console.log(keyArray.length % (d.notes[0] + key));
            console.log(chordName);
            console.log("key: " + keyArray[key]);
            console.log("chord root: "+ keyArray[d.notes[0] + key]);
            console.log("chord tonality: " + chordTonality);
            console.log("chord color: " + extensions[chordColor]);
            console.log("original frequency shape: " + chordShape);

            // construct the midi message this will become and maybe append it as a property in an object with the circle buffer chords

            // extensions (chordColor value is movement from the 7 except for 1 which is no extension which takes the root up an octave)
            if (chordColor == 1) {
                chordShape[3] = chordShape[0] * 2;
            } else {
                chordShape[3] = chordShape[3] * Math.pow(twelthRoot, chordColor);
            }

            // butter
            // remove the third index from the array
            // if (butter == 0) {
            //     chordShape[2] = asdfasdf
            // }

            // voice leading
            // if voiceLeading > 0, calculate array index distance between current and last chord arrays and shift octaves to minimize it proportionate to the value
            // if (d.notes[0] > 6) {
            //     for (var i = 0; i < chordShape.length; i++) {
            //         chordShape[i] /= 2;
            //         console.log("halved " + chordShape[i]);
            //     }
            // }

            // voice openness
            if (openness == 1) {
                // full inversion
                voicedShape = [chordShape[0], chordShape[1] / 2, chordShape[2] / 2, chordShape[3]/2];
            } else if (openness == 2) {
                // partial inversion
                voicedShape = [chordShape[0], chordShape[1], chordShape[2]/2, chordShape[3]/2];
            } else if (openness == 3) {
                // no change
                voicedShape = chordShape;
            } else if (openness == 4) {
                // third-widened
                voicedShape = [chordShape[0], chordShape[1] * 2, chordShape[2], chordShape[3]/2];
            } else if (openness == 5) {
                // third/fifth-widened
                voicedShape = [chordShape[0], chordShape[1] * 2, chordShape[2] * 2, chordShape[3]];
            }

            console.log("voiced frequency shape: " + voicedShape + " " + chordColor);

            // TODO: calculate the frequencies from scratch here instead of using the frequencies array?

            // audio
            for (var i = 0; i < voicedShape.length; i++) {
                // Create an oscillator for each note
                let oscillator = audioContext.createOscillator();
                let gainNode = audioContext.createGain();
                let filter = audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = lowpassCutoff;  
                oscillator.type = waveShape; 
                var now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + attack); // Attack
                // gainNode.gain.linearRampToValueAtTime(0.5, now + 0.2); // Decay
                // gainNode.gain.setValueAtTime(0.5, now + 0.7); // Sustain
                gainNode.gain.linearRampToValueAtTime(0, now + 1); // Release
                oscillator.frequency.value = voicedShape[i];
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 1);
            }

            chordClicked(chordName, color(d.group));

            // visual effect
            d3.select(node._groups[0][d.index])
            .transition()
            .duration(attack * 1000)
            .attr("r", 100)
            .style("fill", "#511")
            .transition()  // Add another transition
            .duration(attack * 20000)
            .attr("r", 50)  // Reset the radius
            .style("fill", function(d) { return color(d.group); });  // Reset the color

            propagateEffect(d);

            // use voicing for next chord voicing

            // random next chord from d links
            // var randomLink = d.links[Math.floor(Math.random() * d.links.length)];
            // console.log("random link = " + randomLink);

            console.log(d.links)
        };

        node.on("click", handleClick);
        labels.on("click", handleClick);

        simulation
            .nodes(graph.nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(graph.links);

        function ticked() {
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            node
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; });

            labels
                .attr("x", function(d) { return d.x; })
                .attr("y", function(d) { return d.y + 7; });
            }
        });

        function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
        }

        function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
        }

        function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
        }

        function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
        }

    </script>
    
</body>
