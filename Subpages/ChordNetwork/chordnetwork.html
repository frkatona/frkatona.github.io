<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chord Network Diagram</title>
    <!-- <link rel="stylesheet" href="chordnetwork.css"> -->
</html>
<script src="https://d3js.org/d3.v4.min.js"></script>
<body>
    <style>
        #overlay {
            display: flex;
            position: fixed;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.7);
            z-index: 2;
            cursor: pointer;
        }

        .overlay-text {
            font-family: 'Roboto', sans-serif;
            text-align: left;
            margin: 10px 0; /* adjust as needed */
            position: relative;
            left: 25%;
            top: 0%;
            font-size: 20px;
            color: white;
        }

        .overlay-click {
            font-family: 'Roboto', sans-serif;
            font-style: italic;
            text-align: center;
            margin: 75px 0; /* adjust as needed */
            position: relative;
            top: 0%;
            font-size: 75px;
            color: white;
        }
        
        h4 {
            font-family: 'Roboto', sans-serif;
            text-align: center;
        }

        #legend {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--background);
            padding: 20px;
            border: 5px solid #000;
            z-index: -1;
            font-size: 20px;
            color: white;
            text-shadow: #000;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        }

        .color-box {
            display: inline-block;
            width: 40px;
            height: 20px;
            margin-right: 5px;
        }

        .unselectable {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        :root {
            --background: #161522;
        }

        body {
            background-color: var(--background);
        }

        #parameters label, #parameters select {
            display: inline-block;
            margin-bottom: 5px;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-weight: bold;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 10%;
            margin-top: 5px
        }

        #parameters input, #parameters select {
            display: inline-block;
            color: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 10%;
        }

        .hamburger {
            font-size: 50px;
            cursor: pointer;
            top: 10px;
            left: 10px;
        }

        .menu {
            display: none;
        }

        #bottomContainer {
            display: flex;
            position: fixed;
            bottom: 10px;
            width: 50%;
        }

        #chordBoxes {
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            bottom: 10px;
            width: 100%;
            height: 100px; /* Adjust as needed */
            background-color: var(--background); /* Adjust as needed */
        }

        #chordBoxes > div {
            border: 5px solid #000;
            width: 100px; /* Adjust as needed */
            height: 100px; /* Adjust as needed */
            margin: 10px 10px; /* Adjust as needed */
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #fff;
            text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
            font-size: 25px;
            font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        #randomNext {
            position: fixed;
            bottom: 75px;
            left: 50px;
            z-index: 1;
            margin-left: 20px;
            background-color: #666666;
            color: white; 
            border: none; 
            padding: 15px 32px; 
            text-align: center; 
            text-decoration: none; 
            display: inline-block;
            font-size: 16px;
            transition-duration: 0.4s; 
            cursor: pointer; 
        }

        #randomNext:hover {
            background-color: #bbbbbb;
            color: black;
        }

        #exportMIDI {

            position: fixed;
            bottom: 20px;
            left: 50px;
            z-index: 1;
            margin-left: 20px;
            background-color: #666666;
            color: white; 
            border: none; 
            padding: 15px 32px; 
            text-align: center; 
            text-decoration: none; 
            display: inline-block;
            font-size: 16px;
            transition-duration: 0.4s; 
            cursor: pointer; 
        }

        #exportMIDI:hover {
            background-color: #bbbbbb;
            color: black;
        }

    </style>

    <script>
        // Global Constants
        //twelth root of two
        const twelthRoot = 1.0594630943592952645618252949463;
        const keyArray = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A","A#", "B"];
        const extensions = {
                0: "7",
                1: "",
                2: " add9",
                4: " add11"
            }
        let repeatTest = false;
        let repeatCounter = 0;
        let clipboardText = "no chords played yet"
        
        // User parameters (audio)
        let key = 0;
        let volume = 0.2;
        let octaveSelect = 4;
        let attack = 0.1;
        let waveShape = "triangle";
        let lowpassCutoff = 4000;
        let randomDelay = 1000;

        // User parameters (UI) [placeholder]
        let chordBars = 4; // use this to construct more boxes as a user UI control later

        // User parameters (chord quality)
        let openness = 3;
        let voiceLeading = 2; //number of inversions
        let butter = 0;
        let chordColor = 0;
        let lastNode = d3.select("#I");

        //random next toggle function
        function toggleRandomNext() {
            if (repeatTest == false) {
                repeatTest = true;
                document.getElementById("randomNext").style.backgroundColor = "green";
            } else {
                repeatTest = false;
                document.getElementById("randomNext").style.backgroundColor = "#666666";
            }
        }
    </script>
    
    <div id="overlay">
        <div class="overlay-click">Welcome!</div>
        <div class="overlay-text">patch 0.9.10</div>
        <div class="overlay-text"> - try using "Copy MIDI" clipboard output with FL piano roll script (found in "../ChordNetwork/data")</div>
        <div class="overlay-text"> - try toggling on the "random next" button at the bottom to automatically play 3 random (linked) chords after your next selection</div>
        <div class="overlay-text"> - try a more colorful wave shape (e.g., sawtooth) with the lowpass slider in the hamburger menu</div>
        <div class="overlay-text"> - try pairing lower octaves with open voicings and higher octaves with closed voicings</div>
        <div class="overlay-text"> - next up: procedural voicing </div>
        <div class="overlay-click">Click anywhere to continue</div>
    </div>

    <div id="legend">
        <h4>chord functions</h4>
        <div><span class="color-box" style="background-color: #04395e"></span> tonic (home)</div>
        <div><span class="color-box" style="background-color: #70a288"></span> pre-dominant (wandering)</div>
        <div><span class="color-box" style="background-color: #c44900"></span> dominant (home-sick)
        </div><h4>link movements</h4>
        <div><span class="color-box" style="background-color: #d00000"></span> driven</div>
        <div><span class="color-box" style="background-color: #3f88c5"></span> regular</div>
        <div><span class="color-box" style="background-color: #136f63"></span> delicate</div>
      </div>

    <button class="hamburger" onclick="toggleMenu()">â˜°</button>

    <div id="parameters" class="menu">
        <form id="parameters">
            <label for="volume">Volume:</label>
            <input type="range" id="volume" name="volume" min="0" max="0.3" step="0.05">
            
            <label for="key">Key:</label>
            <select id="key" name="key">
                <option value="0">C</option>
                <option value="1">C#</option>
                <option value="2">D</option>
                <option value="3">D#</option>
                <option value="4">E</option>
                <option value="5">F</option>
                <option value="6">F#</option>
                <option value="7">G</option>
                <option value="8">G#</option>
                <option value="9">A</option>
                <option value="10">A#</option>
                <option value="11">B</option>
            </select>

            <label for="octaveSelect">Octave:</label>
            <select id="octaveSelect" name="octaveSelect" value="4">
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4"selected>4</option>
                <option value="5">5</option>
            </select>
            
            <label for="waveShape">Wave Shape:</label>
            <select id="waveShape" name="waveShape">
                <option value="sine">Sine</option>
                <option value="square">Square</option>
                <option value="sawtooth">Sawtooth</option>
                <option value="triangle"selected>Triangle</option>
            </select>

            <label for="lowpassCutoff">Lowpass Cutoff:</label>
            <input type="range" id="lowpassCutoff" name="lowpassCutoff" min="300" max="12300" step="2000" oninput="this.title = this.value + ' Hz'">

            <label for="chordColor">Extension:</label>
            <select id="chordColor" name="chordColor">
                <option value="1">None</option>
                <option value="0" selected>7</option>
                <option value="2">add9</option>
                <option value="4">add11</option>
            </select>

            <!-- <label for="openness">Voice Openness:</label>
            <select id="openness" name="openness">
                <option value="1">Very Closed</option>
                <option value="2">Closed</option>
                <option value="3" selected>Original</option>
                <option value="4">Open</option>
                <option value="5">Very Open</option>
            </select> -->

            <label for="voiceLeading">Voice Leading:</label>
            <select id="voiceLeading" name="voiceLeading">
                <option value="0">None</option>
                <option value="3">loose</option>
                <option value="2"selected>modest</option>
                <option value="1">tight</option>
            </select>
        </form>
    </div>

    <div id="bottomContainer">
        <div id="chordBoxes">
            <div id="box1"></div>
            <div id="box2"></div>
            <div id="box3"></div>
            <div id="box4"></div>
        </div>
        <button id="randomNext" onclick="toggleRandomNext()">Random Next</button>
        <button id="exportMIDI" onclick="copyToClipboard()">Copy MIDI</button>
    </div>

    <script>
        window.onload = function() {
            document.getElementById('overlay').style.display = "block";
        }

        document.getElementById('overlay').onclick = function() {
        this.style.display = 'none';
}

        const handlers = {
            'key': (value) => key = parseInt(value),
            'volume': (value) => volume = parseFloat(value),
            'octaveSelect': (value) => octaveSelect = parseInt(value),
            'waveShape': (value) => waveShape = value,
            'openness': (value) => openness = parseInt(value),
            'lowpassCutoff': (value) => lowpassCutoff = parseInt(value),
            'chordColor': (value) => chordColor = parseInt(value)
        };

        document.getElementById('parameters').addEventListener('change', function(e) {
            const handler = handlers[e.target.id];
            if (handler) {
                handler(e.target.value);
            }
        });

        function copyToClipboard() {
            navigator.clipboard.writeText(clipboardText)
                .then(() => {
                console.log('Text copied to clipboard');
                })
                .catch(err => {
                console.error('Error in copying text: ', err);
            });
            var button = document.getElementById('exportMIDI');
            button.innerHTML = 'Copied to clipboard!'; 
            setTimeout(function() {
                button.innerHTML = 'Copy MIDI';
            }, 1000);
        }

        function toggleMenu() {
            var menu = document.getElementById('parameters');
            if (menu.style.display !== 'block') {
                menu.style.display = 'block';
            } else {
                menu.style.display = 'none';
            }
        }
    </script>

    <script>
        var audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        var linkColors = ["#d00000", "#3f88c5", "#136f63"];
        var svg = d3.select("body").append("svg")
        .attr("width", window.innerWidth)
        .attr("height", window.innerHeight);

        var functionColors = ["#04395e", "#70a288", "#c44900"]; // tonic blue; pre-dom green; dom orange
        var color = d3.scaleOrdinal(functionColors);

        var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function(d) { return d.id; })
            .distance(500)  // Set the link distance
            .strength(0.05))  // Set the link strength
        .force("charge", d3.forceManyBody()
            .strength(-250)  // Make nodes repel each other more strongly
            .distanceMin(1)  // Avoid instability for very close nodes
            .distanceMax(100)  // Ignore nodes that are very far away
            .theta(.5))  // Make the simulation run faster but less accurately
        .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2.5));
            
        d3.json("chord-flow-D3.json", function(error, graph) {
            if (error) {
                console.error("Error loading file:", error);  // Log the error to the console
                return;
            }

        var linkColor = d3.scaleOrdinal()
            .domain(["natural", "driven", "delicate"])  // Add all possible types here
            .range([linkColors[0], linkColors[1], linkColors[2]]);  // Add the corresponding colors here

        svg.append("defs").selectAll("marker")
            .data(["end"])      // Different link/path types can be defined here
            .enter().append("marker")    // This section adds in the arrows
            .attr("id", String)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 20)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5");

        var link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graph.links)
            .enter().append("line")
            .attr("id", function(d) { return "link-" + d.id; })  // Assign an ID to each link
            .attr("stroke-width", function(d) { return Math.sqrt(d.value); })
            .attr("stroke", function(d) { return linkColor(d.type); })
            .attr("marker-end", "url(#end)");

        var node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(graph.nodes)
            .enter().append("circle")
            .attr("r", 50)
            .attr("fill", function(d) { return color(d.group); })
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        var labels = svg.append("g")
            .attr("class", "labels")
            .selectAll("text")
            .data(graph.nodes)
            .enter().append("text")
            .attr("class", "unselectable")
            .text(function(d) { return d.id; })
            .style("text-anchor", "middle")
            .style("fill", "#000")
            .style("font-family", "Arial")
            .style("font-size", 30)
            .call(d3.drag()  // Add the same drag handlers to the labels
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        function propagateEffect(node) {

            // Find the links connected to the node as a source
            let linksFrom = graph.links.filter(function(link) {
                return link.source === node;
            });
            // Create a transition for each link
            linksFrom.forEach(function(link) {
                d3.select("#link-" + link.id)
                    .transition()
                    .duration(attack * 2000)
                    .style("stroke", function(d) { return linkColor(d.type); })  // Change the color
                    .style("stroke-width", 8)  // Increase the stroke width
                    .transition()  // Add another transition
                    .duration(1000)  // Set the duration for the second transition
                    .style("stroke", function(d) { return linkColor(d.type); })  // Reset the color
                    .style("stroke-width", function(d) { return Math.sqrt(d.value); });  // Reset the stroke width
            });
            // pick a random node that is connected to the node as a target
            let linksTo = graph.links.filter(function(link) {
                return link.target === node;
            });
            let randomLink = linksTo[Math.floor(Math.random() * linksTo.length)];
            let randomNode = randomLink.source;
            
            if (repeatTest == true && repeatCounter < chordBars - 1) {
                setTimeout(function() { handleClick(randomNode); }, randomDelay);
                repeatCounter++;
            } else {
                // repeatTest = false;
                repeatCounter = 0;
                // document.getElementById("randomNext").style.backgroundColor = "#666666";

            }
        }

        var lastFourChordNames = [];
        var lastFourChordNotes = [];

        function chordClicked(chordName, color, chordNotes) {
            // If there are already four chords, remove the first one
            if (lastFourChordNames.length === 4) {
                lastFourChordNames.shift();
                lastFourChordNotes.shift();
            }

            // Add the new chord and its color
            lastFourChordNames.push({ identity: chordName, color: color });
            lastFourChordNotes.push({ identity: chordNotes});

            // Update the boxes
            for (var i = 0; i < lastFourChordNames.length; i++) {
                var box = document.getElementById('box' + (i + 1));
                box.textContent = lastFourChordNames[i].identity;
                box.style.backgroundColor = lastFourChordNames[i].color;
            }

            // Update the clipboard text with chordNotes
            clipboardText = lastFourChordNotes.map(function(chord) {
                return chord.identity;
            }).join(' ');

            // PLACEHOLDER - add an animation to the box most recently changed (will be box4 except for first 3 clicks)

        }

        function neighbor(chordNotes1, chordNotes2) {
            let neighborDistances_2D = [];
            let goUp = chordNotes1[0] > chordNotes2[0];

            for (let i = 0; i < chordNotes2.length; i++) {
                let distances_1D = chordNotes1.map(value => value - chordNotes2[i]);
                neighborDistances_2D.push(distances_1D);
            }
            return neighborDistances_2D;
        }

        function voiceLeadChord(firstChord, secondChord, voiceLeading) {
            neighborDistances_2D = neighbor(lastFourChordNotes[lastFourChordNotes.length - 1].identity, chordNotes);
            console.log("last chord: " + firstChord);
            console.log("this chord (pre-VL): " + secondChord);
            console.log("neighborDistances_2D: ");
            console.log(neighborDistances_2D);
            
            let voiceLedChord = [];

            // iterate through each column of the neighborDistance 2D array
            for (let i = 0; i < neighborDistances_2D.length; i++) {
                let minInterval = 1000;
                let minIndex = 0;
                let maxInterval = 0;
                let sumIntervals = 0;
                // iterate through each row of the neighborDistance 2D array
                for (let j = 0; j < neighborDistances_2D[i].length; j++) {
                    // if the value is less than the current min, update the min and minIndex
                    if (Math.abs(neighborDistances_2D[i][j]) < minInterval) {
                        minInterval = neighborDistances_2D[i][j];
                        minIndex = j;
                    }
                    // // if the value is greater than the current max, update the max
                    // if (Math.abs(neighborDistances_2D[i][j]) > maxInterval) {
                    //     maxInterval = Math.abs(neighborDistances_2D[i][j]);
                    // }
                    // sumIntervals += Math.abs(neighborDist1ances_2D[i][j]);
                }

                console.log("i="+i+" minInterval: " + minInterval);
                // let j_avg = sumIntervals / neighborDistances_2D[i].length; // measure of openness
                // console.log("i="+i+" maxInterval: " + maxInterval);
                // console.log("i="+i+" avgInterval: " + j_avg);
                
                // push the value as-is
                voiceLedChord.push(secondChord[i])

                // if the smallest inter-chord interval found that index is sufficiently large, move the it an octave towards the smallest interval 
                // (but maybe I should do towards the biggest?)
                if (Math.abs(minInterval) > 6) {
                    let direction = minInterval > 0 ? 1 : -1;
                    voiceLedChord[i] += 12 * direction;
                    console.log('-----------------> minInterval = ' + minInterval + ' so moving note ' + direction + ' octave');
                } 
            }

            console.log("this chord (post-VL): " + voiceLedChord);

            // (PLACEHOLDER) open the chord back up if it's too closed 
            // (first tinker with monitoring the intervals between the notes in the chord and the root)
            for (let i = 1; i < voiceLedChord.length; i++) {
                console.log("inter-chord interval " + i + ": " + (voiceLedChord[i] - voiceLedChord[i-1]));
            }
            
            // force it back to preferred octave if it strayed
            // maybe just do this while I'm moving the notes earlier
            let min = Math.min(...voiceLedChord);
            let max = Math.max(...voiceLedChord);
            if (min < (octaveSelect-1) * 12) {
                for (let i = 0; i < voiceLedChord.length; i++) {
                    voiceLedChord[i] += 12;
                }
            } else if (max > (octaveSelect+1) * 12) {
                for (let i = 0; i < voiceLedChord.length; i++) {
                    voiceLedChord[i] -= 12;
                }
            }

            return voiceLedChord;
        }

        function midiNoteToFrequency(midiNote) {
            const A4 = 440;
            return A4 * Math.pow(2, (midiNote - 69) / 12);
        }

        function handleClick(d) {

            let chordTonality;
            if (d.notes[1] - d.notes[0] == 3){
                chordTonality = "min";
            } else if (d.notes[3] - d.notes[0] == 11) {
                chordTonality = "maj";
            } else {
                chordTonality = "" //dominant
            }

            chordNotes = d.notes.map(note => note + key + ((octaveSelect+1) * 12));
            chordName = keyArray[(d.notes[0] + key + 12) % 12] + chordTonality + extensions[chordColor];
            console.log("d.notes[0]: " + d.notes[0]);
            console.log("key: " + key);
            console.log("keyArray.length: " + keyArray.length);
            console.log(keyArray.length % (d.notes[0] + key));
            console.log(chordName);
            console.log("key: " + keyArray[key]);
            console.log("chord root: "+ keyArray[d.notes[0] + key]);
            console.log("chord tonality: " + chordTonality);
            console.log("chord color: " + extensions[chordColor]);

            // extensions (chordColor value is movement from the 7 except for 1 which is no extension which takes the root up an octave)
            if (chordColor == 1) {
                chordNotes[3] = chordNotes[0] + 12;
            } else {
                if (chordColor > 1) {
                    chordNotes[3] = chordNotes[0] + 12 + chordColor;
                }
            }

            // voice openness
            if (openness == 1) {
                // full inversion
                chordNotes = [chordNotes[0], chordNotes[1] - 12, chordNotes[2] - 12, chordNotes[3] - 12];
            } else if (openness == 2) {
                // partial inversion
                chordNotes = [chordNotes[0], chordNotes[1], chordNotes[2] - 12, chordNotes[3] - 12];
            } else if (openness == 3) {
                // no change
            } else if (openness == 4) {
                // third-widened
                chordNotes = [chordNotes[0], chordNotes[1] + 12, chordNotes[2], chordNotes[3] - 12];
            } else if (openness == 5) {
                // third/fifth-widened
                chordNotes = [chordNotes[0], chordNotes[1] + 12, chordNotes[2] + 12, chordNotes[3]];
            }
            
            // butter
            // remove the third index from the array
            // if (butter == 0) {
            //     array.splice(2, 1)
            // }

            // voice leading
            if (voiceLeading > 0 && lastFourChordNotes.length > 0) {
                chordNotes = voiceLeadChord(lastFourChordNotes[lastFourChordNotes.length - 1].identity, chordNotes, voiceLeading);
            }

            // audio
            for (var i = 0; i < chordNotes.length; i++) {
                // Create an oscillator for each note
                let oscillator = audioContext.createOscillator();
                let gainNode = audioContext.createGain();
                let filter = audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = lowpassCutoff;  
                oscillator.type = waveShape; 
                var now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + attack); // Attack
                // gainNode.gain.linearRampToValueAtTime(0.5, now + 0.2); // Decay
                // gainNode.gain.setValueAtTime(0.5, now + 0.7); // Sustain
                gainNode.gain.linearRampToValueAtTime(0, now + 1); // Release
                oscillator.frequency.value = midiNoteToFrequency(chordNotes[i]);
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 1);
            }

            chordClicked(chordName, color(d.group), chordNotes);

            // visual effect
            d3.select(node._groups[0][d.index])
            .transition()
            .duration(attack * 1000)
            .attr("r", 100)
            .style("fill", "#511")
            .transition()  // Add another transition
            .duration(attack * 20000)
            .attr("r", 50)  // Reset the radius
            .style("fill", function(d) { return color(d.group); });  // Reset the color

            propagateEffect(d);

            console.log("d.links: " + d.links);
        };

        node.on("click", handleClick);
        labels.on("click", handleClick);

        simulation
            .nodes(graph.nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(graph.links);

        function ticked() {
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            node
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; });

            labels
                .attr("x", function(d) { return d.x; })
                .attr("y", function(d) { return d.y + 7; });
            }
        });

        function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
        }

        function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
        }

        function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
        }

        function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
        }


    </script>
    
</body>