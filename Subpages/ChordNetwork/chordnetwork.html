<!DOCTYPE html>
<script src="https://d3js.org/d3.v4.min.js"></script>
<body>
    
    <style>
        .unselectable {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background-color: #161522;
        }

        #parameters label, #parameters select {
            display: inline-block;
            margin-bottom: 5px;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-weight: bold;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 10%;
            margin-top: 5px
        }

        #parameters input, #parameters select {
            display: inline-block;
            color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 10%;
        }

        .hamburger {
            /* position: absolute; */
            font-size: 50px;
            cursor: pointer;
            top: 10px;
            left: 10px;
        }

        .menu {
            display: none;
            /* position: absolute; */
        }

    </style>

    <script>
        // Global Constants
        //twelth root of two
        const twelthRoot = 1.0594630943592952645618252949463;

        // User parameters (audio)
        var key = 0;
        var volume = 0.2;
        var octaveSelect = 4;
        var attack = 0.1;
        var waveShape = "sine";
        var lowpassCutoff = 4000;

        // User parameters placeholder (UI)
        
        // User parameters placeholder (chord quality)
        var openness = 3;
        var voiceLeading = 0.1;
        var butter = 0.5;
        var chordColor = 0;
        var lastChord = null;
    </script>
    
    <button class="hamburger" onclick="toggleMenu()">â˜°</button>

    <div id="parameters" class="menu">
        <form id="parameters">
            <label for="volume">Volume:</label>
            <input type="range" id="volume" name="volume" min="0" max="0.3" step="0.05">
            
            <label for="key">Key:</label>
            <select id="key" name="key">
                <option value="0">C</option>
                <option value="1">C#</option>
                <option value="2">D</option>
                <option value="3#">D#</option>
                <option value="4">E</option>
                <option value="5">F</option>
                <option value="6#">F#</option>
                <option value="7">G</option>
                <option value="8#">G#</option>
                <option value="9">A</option>
                <option value="10#">A#</option>
                <option value="11">B</option>
            </select>

            <label for="octaveSelect">Octave:</label>
            <select id="octaveSelect" name="octaveSelect" value="4">
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
            </select>
            
            <label for="waveShape">Wave Shape:</label>
            <select id="waveShape" name="waveShape">
                <option value="sine">Sine</option>
                <option value="square">Square</option>
                <option value="sawtooth">Sawtooth</option>
                <option value="triangle">Triangle</option>
            </select>

            <label for="lowpassCutoff">Lowpass Cutoff:</label>
            <input type="range" id="lowpassCutoff" name="lowpassCutoff" min="300" max="12300" step="2000" oninput="this.title = this.value + ' Hz'">
            
            <label for="chordColor">Extension:</label>
            <select id="chordColor" name="chordColor">
                <option value="1">None</option>
                <option value="0" selected>7</option>
                <option value="2">add9</option>
                <option value="4">add11</option>
            </select>

            <label for="openness">Voice Openness:</label>
            <select id="openness" name="openness">
                <option value="1">Very Closed</option>
                <option value="2">Closed</option>
                <option value="3" selected>Original</option>
                <option value="4">Open</option>
                <option value="5">Very Open</option>
            </select>
        </form>
    </div>
    
    <script>
        const handlers = {
            'key': (value) => key = parseInt(value),
            'volume': (value) => volume = parseFloat(value),
            'octaveSelect': (value) => octaveSelect = parseInt(value),
            'waveShape': (value) => waveShape = value,
            'openness': (value) => openness = parseInt(value),
            'lowpassCutoff': (value) => lowpassCutoff = parseInt(value),
            'chordColor': (value) => chordColor = parseInt(value)
        };

        document.getElementById('parameters').addEventListener('change', function(e) {
            const handler = handlers[e.target.id];
            if (handler) {
                handler(e.target.value);
            }
        });


        function toggleMenu() {
            var menu = document.getElementById('parameters');
            if (menu.style.display !== 'block') {
                menu.style.display = 'block';
            } else {
                menu.style.display = 'none';
            }
        }
    </script>

    <script>
        var audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        var colors = ["#d00000", "#ffba08", "#3f88c5", "#032b43", "#136f63", "#66635b"];
        var svg = d3.select("body").append("svg")
        .attr("width", window.innerWidth)
        .attr("height", window.innerHeight);

        var color = d3.scaleOrdinal(d3.schemeCategory20);

        var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function(d) { return d.id; })
            .distance(500)  // Set the link distance
            .strength(0.05))  // Set the link strength
        .force("charge", d3.forceManyBody()
            .strength(-250)  // Make nodes repel each other more strongly
            .distanceMin(1)  // Avoid instability for very close nodes
            .distanceMax(100)  // Ignore nodes that are very far away
            .theta(.5))  // Make the simulation run faster but less accurately
        .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));
            
        d3.json("chord-flow-D3.json", function(error, graph) {
            if (error) {
                console.error("Error loading file:", error);  // Log the error to the console
                return;
            }

        var linkColor = d3.scaleOrdinal()
            .domain(["natural", "driven", "delicate"])  // Add all possible types here
            .range([colors[0], colors[2], colors[4]]);  // Add the corresponding colors here

        svg.append("defs").selectAll("marker")
            .data(["end"])      // Different link/path types can be defined here
            .enter().append("marker")    // This section adds in the arrows
            .attr("id", String)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 20)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5");

        var link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graph.links)
            .enter().append("line")
            .attr("id", function(d) { return "link-" + d.id; })  // Assign an ID to each link
            .attr("stroke-width", function(d) { return Math.sqrt(d.value); })
            .attr("stroke", function(d) { return linkColor(d.type); })
            .attr("marker-end", "url(#end)");

        var node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(graph.nodes)
            .enter().append("circle")
            .attr("r", 50)
            .attr("fill", function(d) { return color(d.group); })
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        var labels = svg.append("g")
            .attr("class", "labels")
            .selectAll("text")
            .data(graph.nodes)
            .enter().append("text")
            .attr("class", "unselectable")
            .text(function(d) { return d.id; })
            .style("text-anchor", "middle")
            .style("fill", "#000")
            .style("font-family", "Arial")
            .style("font-size", 30)
            .call(d3.drag()  // Add the same drag handlers to the labels
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

            function propagateEffect(node) {

                // Find the links connected to the node
                let connectedLinks = graph.links.filter(function(link) {
                    return link.source === node;
                });
                // Create a transition for each link
                connectedLinks.forEach(function(link) {
                    d3.select("#link-" + link.id)
                        .transition()
                        .duration(attack * 2000)
                        .style("stroke", function(d) { return linkColor(d.type); })  // Change the color
                        .style("stroke-width", 8)  // Increase the stroke width
                        .transition()  // Add another transition
                        .duration(1000)  // Set the duration for the second transition
                        .style("stroke", function(d) { return linkColor(d.type); })  // Reset the color
                        .style("stroke-width", function(d) { return Math.sqrt(d.value); });  // Reset the stroke width
                });
            }

        
        function handleClick(d) {
            // Define the frequencies for the notes starting from C1 and then correct for octave and key selection
            let frequencies = [32.70, 34.65, 36.71, 38.89, 41.20, 43.65, 46.25, 48.99, 51.91, 55.00, 58.27, 61.74, 65.41, 69.30, 73.42, 77.78, 82.41, 87.31, 92.50, 98.00, 103.83, 110.00, 116.54, 123.47]; // C1 to B2
            frequencies = frequencies.map(function(value) {
                octaveCorrected = value * Math.pow(2, octaveSelect - 1);
                keyCorrected = octaveCorrected * Math.pow(twelthRoot, key);
                return keyCorrected;
            });

            let chordShape = d.notes.map(note => frequencies[note]);
            
            console.log("original: " + chordShape);

            // extensions (chordColor value is movement from the 7 except for 1 which is no extension which takes the root up an octave)
            if (chordColor == 1) {
                chordShape[3] = chordShape[0] * 2;
            } else {
                chordShape[3] = chordShape[3] * Math.pow(twelthRoot, chordColor);
            }

            // butter
            // if butter = False, remove the 5

            // voice leading
            // if voiceLeading > 0, calculate array index distance between current and last chord arrays and shift octaves to minimize it proportionate to the value


            // voice openness
            if (openness == 1) {
                // full inversion
                voicedShape = [chordShape[0], chordShape[1] / 2, chordShape[2] / 2, chordShape[3]/2];
            } else if (openness == 2) {
                // partial inversion
                voicedShape = [chordShape[0], chordShape[1], chordShape[2]/2, chordShape[3]/2];
            } else if (openness == 3) {
                // no change
                voicedShape = chordShape;
            } else if (openness == 4) {
                // third-widened
                voicedShape = [chordShape[0], chordShape[1] * 2, chordShape[2], chordShape[3]/2];
            } else if (openness == 5) {
                // third/fifth-widened
                voicedShape = [chordShape[0], chordShape[1] * 2, chordShape[2] * 2, chordShape[3]];
            }

            console.log("voiced shape: " + voicedShape + " " + chordColor);

            // TODO: calculate the frequencies from scratch here instead of using the frequencies array?

            // audio
            for (var i = 0; i < voicedShape.length; i++) {
                // Create an oscillator for each note
                let oscillator = audioContext.createOscillator();
                let gainNode = audioContext.createGain();
                let filter = audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = lowpassCutoff;  
                oscillator.type = waveShape; 
                var now = audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + attack); // Attack
                // gainNode.gain.linearRampToValueAtTime(0.5, now + 0.2); // Decay
                // gainNode.gain.setValueAtTime(0.5, now + 0.7); // Sustain
                gainNode.gain.linearRampToValueAtTime(0, now + 1); // Release
                oscillator.frequency.value = voicedShape[i];
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 1);
            }

            // visual effect
            d3.select(node._groups[0][d.index])
            .transition()
            .duration(attack * 1000)
            .attr("r", 100)
            .style("fill", "#511")
            .transition()  // Add another transition
            .duration(attack * 20000)
            .attr("r", 50)  // Reset the radius
            .style("fill", function(d) { return color(d.group); });  // Reset the color

            propagateEffect(d);

            lastChord = d;
        };

        node.on("click", handleClick);
        labels.on("click", handleClick);

        simulation
            .nodes(graph.nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(graph.links);

        function ticked() {
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            node
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; });

            labels
                .attr("x", function(d) { return d.x; })
                .attr("y", function(d) { return d.y + 7; });
            }
        });

        function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
        }

        function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
        }

        function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
        }

        function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
        }
    </script>
</body>
